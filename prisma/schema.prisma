generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum UserRole {
  PHOTOGRAPHER
  BUYER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  email         String    @unique
  emailVerified DateTime?
  passwordHash  String?
  name          String?
  image         String?
  roles         UserRole[] @default([BUYER])

  // Telegram integration
  telegramUserId    String?   @unique
  telegramUsername  String?
  telegramLinkedAt  DateTime?

  // Relations
  photographerProfile PhotographerProfile?
  photos              Photo[]
  licenseRequests     LicenseRequest[]
  adminReviews        AdminReview[]
  telegramLinkTokens  TelegramLinkToken[]
  accounts            Account[]
  sessions            Session[]

  @@index([email])
  @@index([telegramUserId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// PHOTOGRAPHER PROFILE
// ============================================

model PhotographerProfile {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  userId          String   @unique
  displayName     String
  handle          String   @unique
  bio             String?  @db.Text
  location        String?
  websiteUrl      String?
  socialInstagram String?
  socialX         String?
  socialLinkedin  String?
  avatarUrl       String?
  coverImageUrl   String?
  isVerified      Boolean  @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([handle])
}

// ============================================
// PHOTOS & VERIFICATION
// ============================================

enum PhotoStatus {
  UPLOADING
  PENDING_REVIEW
  VERIFIED
  REJECTED
}

model Photo {
  id              String      @id @default(cuid())
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  photographerId  String

  // Basic info
  title           String
  description     String?     @db.Text

  // File storage
  fileUrl         String
  thumbnailUrl    String?
  mediumUrl       String?
  storageKey      String

  // Status & verification
  status          PhotoStatus @default(UPLOADING)
  verificationScore Float?
  verificationNotes String?    @db.Text
  verifiedAt      DateTime?

  // Technical metadata (EXIF)
  width           Int?
  height          Int?
  fileSize        Int?
  mimeType        String?
  shootDate       DateTime?
  cameraMake      String?
  cameraModel     String?
  lens            String?
  aperture        String?
  shutterSpeed    String?
  iso             Int?
  focalLength     String?
  gpsLatitude     Float?
  gpsLongitude    Float?

  // Integrity
  fileHash        String      @unique

  // Visual analysis (optional)
  primaryColor    String?
  dominantColors  String[]

  // Relations
  photographer    User        @relation(fields: [photographerId], references: [id], onDelete: Cascade)
  tags            PhotoTag[]
  licenseOptions  LicenseOption[]
  licenseRequests LicenseRequest[]
  adminReviews    AdminReview[]

  @@index([photographerId])
  @@index([status])
  @@index([createdAt])
  @@index([fileHash])
}

model Tag {
  id        String     @id @default(cuid())
  name      String     @unique
  slug      String     @unique
  photos    PhotoTag[]

  @@index([slug])
}

model PhotoTag {
  photoId String
  tagId   String
  photo   Photo  @relation(fields: [photoId], references: [id], onDelete: Cascade)
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([photoId, tagId])
}

// ============================================
// LICENSING
// ============================================

enum LicenseType {
  PERSONAL
  EDITORIAL
  COMMERCIAL
  EXTENDED
}

model LicenseOption {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  photoId     String
  type        LicenseType
  name        String
  description String?     @db.Text
  priceCents  Int
  currency    String      @default("USD")
  usageTerms  String?     @db.Text
  isActive    Boolean     @default(true)

  photo       Photo       @relation(fields: [photoId], references: [id], onDelete: Cascade)
  requests    LicenseRequest[]

  @@index([photoId])
}

enum RequestStatus {
  OPEN
  IN_REVIEW
  APPROVED
  DECLINED
  COMPLETED
}

model LicenseRequest {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  photoId         String
  buyerId         String
  licenseOptionId String?
  status          RequestStatus @default(OPEN)
  message         String?       @db.Text
  intendedUse     String?       @db.Text
  adminNotes      String?       @db.Text

  photo         Photo         @relation(fields: [photoId], references: [id], onDelete: Cascade)
  buyer         User          @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  licenseOption LicenseOption? @relation(fields: [licenseOptionId], references: [id])

  @@index([photoId])
  @@index([buyerId])
  @@index([status])
}

// ============================================
// ADMIN & MODERATION
// ============================================

enum ReviewDecision {
  VERIFIED
  REJECTED
  NEEDS_INFO
}

model AdminReview {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  photoId   String
  adminId   String
  decision  ReviewDecision
  notes     String?        @db.Text

  photo Photo @relation(fields: [photoId], references: [id], onDelete: Cascade)
  admin User  @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([photoId])
  @@index([adminId])
}

// ============================================
// TELEGRAM INTEGRATION
// ============================================

model TelegramLinkToken {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  usedAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}
