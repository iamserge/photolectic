generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & AUTHENTICATION
// ============================================

enum UserRole {
  PHOTOGRAPHER
  BUYER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  email         String    @unique
  emailVerified DateTime?
  passwordHash  String?
  name          String?
  image         String?
  roles         UserRole[] @default([BUYER])

  // Telegram integration
  telegramUserId    String?   @unique
  telegramUsername  String?
  telegramLinkedAt  DateTime?

  // Relations
  photographerProfile  PhotographerProfile?
  photos               Photo[]
  licenseRequests      LicenseRequest[]
  adminReviews         AdminReview[]
  telegramLinkTokens   TelegramLinkToken[]
  accounts             Account[]
  sessions             Session[]
  wallet               Wallet?
  purchases            Purchase[]       @relation("BuyerPurchases")
  buyerRequests        PhotoRequest[]   @relation("BuyerRequests")
  photographerRequests PhotoRequest[]   @relation("PhotographerRequests")

  @@index([email])
  @@index([telegramUserId])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// PHOTOGRAPHER PROFILE
// ============================================

model PhotographerProfile {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  userId          String   @unique
  displayName     String
  handle          String   @unique
  bio             String?  @db.Text
  location        String?
  websiteUrl      String?
  socialInstagram String?
  socialX         String?
  socialLinkedin  String?
  avatarUrl       String?
  coverImageUrl   String?
  isVerified      Boolean  @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([handle])
}

// ============================================
// PHOTOS & VERIFICATION
// ============================================

enum PhotoStatus {
  UPLOADING
  PENDING_REVIEW
  VERIFIED
  REJECTED
}

model Photo {
  id              String      @id @default(cuid())
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  photographerId  String

  // Basic info
  title           String
  description     String?     @db.Text
  category        String?

  // File storage
  fileUrl         String
  thumbnailUrl    String?
  mediumUrl       String?
  storageKey      String
  location        String?

  // Status & verification
  status          PhotoStatus @default(UPLOADING)
  verificationScore Float?
  verificationNotes String?    @db.Text
  verifiedAt      DateTime?

  // Technical metadata (EXIF)
  width           Int?
  height          Int?
  fileSize        Int?
  mimeType        String?
  shootDate       DateTime?
  cameraMake      String?
  cameraModel     String?
  lens            String?
  aperture        String?
  shutterSpeed    String?
  iso             Int?
  focalLength     String?
  gpsLatitude     Float?
  gpsLongitude    Float?

  // Integrity
  fileHash        String      @unique

  // Visual analysis (optional)
  primaryColor    String?
  dominantColors  String[]

  // Relations
  photographer      User        @relation(fields: [photographerId], references: [id], onDelete: Cascade)
  tags              PhotoTag[]
  licenseOptions    LicenseOption[]
  licenseRequests   LicenseRequest[]
  adminReviews      AdminReview[]
  purchases         Purchase[]
  deliveredRequests PhotoRequest[] @relation("DeliveredPhoto")

  @@index([photographerId])
  @@index([status])
  @@index([createdAt])
  @@index([fileHash])
  @@index([category])
}

model Tag {
  id        String     @id @default(cuid())
  name      String     @unique
  slug      String     @unique
  photos    PhotoTag[]

  @@index([slug])
}

model PhotoTag {
  photoId String
  tagId   String
  photo   Photo  @relation(fields: [photoId], references: [id], onDelete: Cascade)
  tag     Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([photoId, tagId])
}

// ============================================
// LICENSING
// ============================================

enum LicenseType {
  PERSONAL
  EDITORIAL
  COMMERCIAL
  EXTENDED
}

model LicenseOption {
  id          String      @id @default(cuid())
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  photoId     String
  type        LicenseType
  name        String
  description String?     @db.Text
  priceCents  Int
  credits     Int         @default(0) // Price in credits
  currency    String      @default("USD")
  usageTerms  String?     @db.Text
  isActive    Boolean     @default(true)

  photo     Photo       @relation(fields: [photoId], references: [id], onDelete: Cascade)
  requests  LicenseRequest[]
  purchases Purchase[]

  @@index([photoId])
}

enum RequestStatus {
  OPEN
  IN_REVIEW
  APPROVED
  DECLINED
  COMPLETED
}

model LicenseRequest {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  photoId         String
  buyerId         String
  licenseOptionId String?
  status          RequestStatus @default(OPEN)
  message         String?       @db.Text
  intendedUse     String?       @db.Text
  adminNotes      String?       @db.Text

  photo         Photo         @relation(fields: [photoId], references: [id], onDelete: Cascade)
  buyer         User          @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  licenseOption LicenseOption? @relation(fields: [licenseOptionId], references: [id])

  @@index([photoId])
  @@index([buyerId])
  @@index([status])
}

// ============================================
// ADMIN & MODERATION
// ============================================

enum ReviewDecision {
  VERIFIED
  REJECTED
  NEEDS_INFO
}

model AdminReview {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  photoId   String
  adminId   String
  decision  ReviewDecision
  notes     String?        @db.Text

  photo Photo @relation(fields: [photoId], references: [id], onDelete: Cascade)
  admin User  @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([photoId])
  @@index([adminId])
}

// ============================================
// TELEGRAM INTEGRATION
// ============================================

model TelegramLinkToken {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  usedAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}

// ============================================
// WALLET & CREDITS SYSTEM
// ============================================

model Wallet {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        String   @unique
  balance       Int      @default(0) // Credits balance
  totalSpent    Int      @default(0) // Total credits spent
  totalEarnings Int      @default(0) // For photographers - lifetime earnings
  pendingPayout Int      @default(0) // Pending photographer earnings

  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions CreditTransaction[]
}

enum TransactionType {
  CREDIT_PURCHASE      // Buyer purchased credits
  PHOTO_PURCHASE       // Buyer spent credits on a photo
  PHOTOGRAPHER_EARNING // Photographer received credits from sale
  REFUND               // Credits refunded
  BONUS                // Promotional credits
}

model CreditTransaction {
  id          String          @id @default(cuid())
  createdAt   DateTime        @default(now())
  walletId    String
  type        TransactionType
  amount      Int             // Positive for credits in, negative for credits out
  balance     Int             // Balance after transaction
  description String?
  metadata    Json?           // Store payment info, photo ID, etc.

  wallet     Wallet    @relation(fields: [walletId], references: [id], onDelete: Cascade)
  purchase   Purchase? @relation(fields: [purchaseId], references: [id])
  purchaseId String?

  @@index([walletId])
  @@index([type])
  @@index([createdAt])
}

// ============================================
// PURCHASES & DOWNLOADS
// ============================================

enum PurchaseStatus {
  PENDING
  COMPLETED
  REFUNDED
}

model Purchase {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  buyerId         String
  photoId         String
  licenseOptionId String
  status          PurchaseStatus @default(COMPLETED)
  creditsCost     Int            // Credits spent
  photographerCut Int            // Credits to photographer (80%)
  platformCut     Int            // Platform fee (20%)
  downloadToken   String         @unique @default(cuid())
  downloadCount   Int            @default(0)
  maxDownloads    Int            @default(5)

  buyer         User                @relation("BuyerPurchases", fields: [buyerId], references: [id])
  photo         Photo               @relation(fields: [photoId], references: [id])
  licenseOption LicenseOption       @relation(fields: [licenseOptionId], references: [id])
  transactions  CreditTransaction[]

  @@index([buyerId])
  @@index([photoId])
  @@index([downloadToken])
  @@index([status])
}

// ============================================
// PHOTO REQUESTS (Custom commissions)
// ============================================

enum PhotoRequestStatus {
  PENDING
  ACCEPTED
  IN_PROGRESS
  DELIVERED
  COMPLETED
  DECLINED
  CANCELLED
}

model PhotoRequest {
  id             String             @id @default(cuid())
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  buyerId        String
  photographerId String
  status         PhotoRequestStatus @default(PENDING)

  // Request details
  title          String
  description    String             @db.Text
  category       String?
  budget         Int?               // Budget in credits
  deadline       DateTime?

  // Response
  photographerNotes String?         @db.Text
  quotedPrice    Int?               // Photographer's quote in credits

  // Delivery
  deliveredPhotoId String?

  buyer          User   @relation("BuyerRequests", fields: [buyerId], references: [id])
  photographer   User   @relation("PhotographerRequests", fields: [photographerId], references: [id])
  deliveredPhoto Photo? @relation("DeliveredPhoto", fields: [deliveredPhotoId], references: [id])

  @@index([buyerId])
  @@index([photographerId])
  @@index([status])
}
